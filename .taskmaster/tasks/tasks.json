{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Database Connection and Environment Configuration",
        "description": "Configure Supabase database connection using the JavaScript client and environment variables for the Beachwatch Data Explorer",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Install and configure Supabase JavaScript client for direct database access. Set up environment variables for database connection (SUPABASE_URL, SUPABASE_ANON_KEY). Create lib/supabase.ts for client configuration. Install dependency: @supabase/supabase-js. Optionally generate TypeScript types from database schema using Supabase CLI. This approach provides direct, type-safe database access perfect for read-heavy analytics use cases with built-in connection pooling and caching.",
        "testStrategy": "Verify database connection with a simple query test. Test Supabase client initialization and basic data fetching operations on regions table. Validate environment variables are properly loaded and client is configured correctly.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Supabase JavaScript client",
            "description": "Install @supabase/supabase-js dependency",
            "status": "done",
            "dependencies": [],
            "details": "Run npm install @supabase/supabase-js to add the Supabase client library",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure environment variables",
            "description": "Set up SUPABASE_URL and SUPABASE_ANON_KEY in environment configuration",
            "status": "done",
            "dependencies": [],
            "details": "Create or update .env.local with SUPABASE_URL and SUPABASE_ANON_KEY. Add these variables to .env.example for documentation. Ensure variables are properly typed in next.config.ts if needed",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Supabase client configuration",
            "description": "Create lib/supabase.ts with client setup",
            "status": "done",
            "dependencies": [],
            "details": "Create lib/supabase.ts file with createClient function from @supabase/supabase-js. Configure client with environment variables and appropriate options for Next.js Server Components",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Test database connection",
            "description": "Verify Supabase client can connect and query the database",
            "status": "done",
            "dependencies": [],
            "details": "Create a simple test to verify database connection by querying the regions table. Test both client-side and server-side usage patterns",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Generate TypeScript types (optional)",
            "description": "Generate TypeScript types from database schema",
            "status": "done",
            "dependencies": [],
            "details": "Use Supabase CLI to generate TypeScript types from the database schema for type-safe database operations. Configure type generation in package.json scripts",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Install and Configure Core Dependencies",
        "description": "Install required libraries for mapping, data visualization, state management, and UI components as specified in the PRD",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Install React Query (@tanstack/react-query) v5.x for server state management. Install shadcn/ui charts component using 'npx shadcn@latest add chart' for data visualization (this automatically includes recharts as a dependency). Install Leaflet with react-leaflet v4.x for mapping (open source alternative to Mapbox). Install Sonner v1.x for notifications. Add additional shadcn/ui components: Card, Button, Select, Checkbox, Slider, Tooltip, Dialog, Sidebar. Configure React Query with QueryClient and proper error boundaries.",
        "testStrategy": "Verify all dependencies are properly installed and importable. Test React Query client initialization. Validate shadcn/ui charts can render basic charts. Test Leaflet initialization with sample data.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Core Application Layout and Navigation Structure",
        "description": "Build the main application layout with responsive design, including map area, sidebar for filters, and engagement stats panel",
        "details": "Create responsive layout component with CSS Grid: map occupying ~70% width on desktop, full width on mobile. Implement collapsible left sidebar for filters using shadcn/ui Sidebar component. Create fixed engagement stats panel on right side (desktop) or below map (mobile). Add proper responsive breakpoints using Tailwind CSS. Implement header with application title and branding. Use Inter font from next/font/google for typography. Apply environmental color scheme (blues/greens) with CSS custom properties.",
        "testStrategy": "Test responsive behavior across desktop, tablet, and mobile viewports. Verify sidebar collapse/expand functionality. Test layout integrity with different content sizes.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement UK Geographic Regions Data Management",
        "description": "Create data models, API routes, and services for managing UK geographic regions with jsonb geometry data integration using Supabase JavaScript client",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Create API routes in app/api/regions/ for fetching region data using Supabase client. Implement direct Supabase queries for hierarchical region structure (country > county > unitary authority) leveraging built-in REST API. Create region service functions for data transformation handling existing jsonb geometry fields containing GeoJSON Polygon objects. Implement caching strategy with React Query and Supabase's built-in connection pooling. Add region boundary coordinate validation for jsonb polygon data. Handle geometry field structure: {\"type\": \"Polygon\", \"coordinates\": [[[lng, lat], [lng, lat], ...]]}. IMPORTANT: Use correct database schema field names - `name_id` in annual_region_aggregates table, `additional_area_cleaned_m` (not additional_areas_cleaned_m), and `parent_id` in regions table (not parent_region_id). Work with existing jsonb geometry field data for all 226 UK regions with complete boundary coverage across 4 hierarchy levels.",
        "testStrategy": "Test region data fetching with various geographic levels using Supabase client. Validate jsonb GeoJSON Polygon structure and coordinate integrity. Test region hierarchy queries for parent/child relationships using Supabase REST API. Verify API performance with large boundary datasets leveraging built-in connection pooling. Test queries against production schema using correct field names (name_id, additional_area_cleaned_m, parent_id). Test jsonb polygon coordinate processing for map rendering with existing complete boundary data.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create API routes for regions data with Supabase client",
            "description": "Implement Next.js API routes in app/api/regions/ using Supabase JavaScript client for fetching UK geographic regions data with jsonb geometry handling and proper error handling",
            "status": "done",
            "dependencies": [],
            "details": "Create API endpoints using Supabase client: GET /api/regions for all regions, GET /api/regions/[id] for specific region, GET /api/regions/hierarchy for parent-child relationships. Implement proper TypeScript interfaces for Supabase response objects including jsonb geometry field structure. Add input validation and error handling using Supabase error types. Configure rate limiting and CORS headers. Utilize Supabase's built-in connection pooling and automatic retries. Use correct schema field names: `parent_id` for region hierarchy queries. Handle jsonb geometry data extraction and parsing for API responses with existing boundary data.\n<info added on 2025-08-19T11:20:31.785Z>\nImplementation completed successfully. All three main API endpoints created with comprehensive query parameters and proper error handling. TypeScript interfaces integrated with Supabase client. Rate limiting, caching headers, and geometry validation implemented using existing utility functions. All schema field names correctly used including parent_id, name_id, and additional_area_cleaned_m for proper database integration.\n</info added on 2025-08-19T11:20:31.785Z>",
            "testStrategy": "Test API endpoints with jsonb geometry data extraction. Verify TypeScript interfaces handle jsonb polygon structure correctly."
          },
          {
            "id": 2,
            "title": "Implement Supabase queries for hierarchical region structure",
            "description": "Build database queries using Supabase JavaScript client to handle hierarchical UK region data structure with jsonb geometry data extraction from existing boundary data",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Create Supabase queries for nested region relationships using select with joins on `parent_id` field. Implement functions using supabase.from(): findRegionsByParent, getRegionHierarchy, searchRegionsByName. Include jsonb geometry field selection in queries for existing boundary data. Utilize Supabase's built-in filtering and ordering capabilities. Handle region type filtering (country, county, unitary authority) with Supabase query builders. Leverage automatic connection management and query optimization. Ensure queries use correct field name `parent_id` for hierarchy relationships and properly extract jsonb polygon data from the complete existing dataset.\n<info added on 2025-08-19T14:11:21.239Z>\n**Implementation Complete - Comprehensive Supabase Region Queries System**\n\nSuccessfully implemented full hierarchical region query system with RegionQueries class in region-queries.ts featuring findRegionsByParent, getRegionHierarchy, searchRegionsByName, getRegionPath, getRegionsByType, getRegionStatistics, and validateHierarchy functions. All queries properly use parent_id field and include efficient hierarchy building with Maps for O(1) lookups, descendant counting, and circular reference detection.\n\nCreated corresponding React Query hooks in use-region-queries.ts with complete cache management, query key factories, prefetch helpers, and mutation support. System includes comprehensive error handling, performance optimization, and flexible query options (includeGeometry, includeChildren, includeParent, includeAggregates, maxDepth, orderBy). Enhanced RegionWithRelations interface provides full type safety for hierarchical data structures.\n\nAll queries leverage Supabase's built-in REST API, connection pooling, and query builders for optimal performance with the existing UK regions dataset containing jsonb geometry fields.\n</info added on 2025-08-19T14:11:21.239Z>",
            "testStrategy": "Test queries return correct jsonb geometry structure alongside hierarchical data. Verify polygon coordinate extraction works correctly with existing boundary data."
          },
          {
            "id": 3,
            "title": "Implement jsonb GeoJSON processing for coordinate validation",
            "description": "Build GeoJSON processing pipeline for jsonb polygon data validation and coordinate processing without PostGIS geometry types using existing boundary data",
            "status": "done",
            "dependencies": [],
            "details": "Implement JavaScript-based coordinate validation for existing jsonb polygon data. Create functions to validate GeoJSON Polygon structure stored in jsonb fields. Add coordinate bounds checking using standard JavaScript geometry calculations. Implement polygon simplification algorithms for different zoom levels. Create functions: validateJsonbPolygon, simplifyPolygonCoordinates, calculatePolygonBounds, optimizeForZoom. Handle invalid geometries with JavaScript validation functions. Work directly with coordinate arrays from jsonb structure of existing complete boundary dataset.\n<info added on 2025-08-19T11:23:16.969Z>\nImplementation completed successfully with comprehensive geometry processing capabilities. Created three core modules: geometry-utils.ts with validation functions (validateJsonbPolygon/MultiPolygon, calculatePolygonBounds, simplifyPolygonCoordinates with Douglas-Peucker algorithm, optimizeForZoom, UK coordinate bounds checking), spatial-operations.ts with advanced algorithms (pointInPolygon using ray casting, calculateDistance with Haversine formula, calculatePolygonArea with Shoelace formula, findIntersections, createBuffer, executeSpatialQuery, CoordinateTransformations class), and region-geometry-service.ts as service layer (validateGeometry, processGeometry with metadata calculation, validateRegionFromDB, spatial query functions, batch processing). All functions implemented in pure JavaScript without PostGIS dependency, handle existing jsonb polygon structure correctly, include comprehensive error handling with coordinate bounds validation, ring closure checks, duplicate detection, and performance warnings for large geometries.\n</info added on 2025-08-19T11:23:16.969Z>",
            "testStrategy": "Test coordinate validation with existing jsonb polygon structures. Verify simplification maintains polygon integrity with real boundary data."
          },
          {
            "id": 4,
            "title": "Setup React Query caching with Supabase integration",
            "description": "Implement comprehensive caching strategy using React Query integrated with Supabase's built-in caching and real-time capabilities for jsonb geometry data",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Configure React Query client to work with Supabase client queries including jsonb geometry data from existing boundaries. Implement query keys structure for hierarchical caching with Supabase data. Add prefetching strategies using Supabase's connection pooling. Create cache invalidation rules integrated with Supabase real-time subscriptions. Set up background refetching leveraging Supabase's automatic retry mechanisms and built-in performance optimizations. Handle jsonb polygon data serialization in cache for all 226 regions.\n<info added on 2025-08-19T14:14:21.687Z>\nSuccessfully completed React Query caching implementation with comprehensive Supabase integration. Enhanced query-client.ts with Supabase-optimized configurations including custom retry logic for PGRST errors, exponential backoff with jitter, extended garbage collection for geometry data, and custom geometry serialization with validation. Implemented SupabaseQueryClient class with advanced caching methods including setGeometryCache with priority-based stale times, prefetchRegionHierarchy for progressive loading, invalidateRegionQueries with smart cascade invalidation, startBackgroundSync for automatic refreshing, optimizeMemoryUsage for large datasets, and getCacheStats for monitoring. Created supabase-query-provider.tsx with real-time subscriptions to regions and aggregates tables, automatic cache invalidation on database changes, background synchronization with configurable intervals, memory optimization with cleanup, connection status monitoring, and development debug component. Added cache-strategies.ts with production-ready CACHE_STRATEGIES for different data types, CachePreloadingStrategies for essential data and exploration workflows, CacheOptimizer with usage analysis and predictive prefetching, and CacheWarming for deployment optimization. The implementation properly handles jsonb polygon data serialization in cache, provides real-time cache invalidation synchronized with database changes, implements progressive loading for large boundary datasets, and efficiently manages all 226 UK regions with complete geometry coverage.\n</info added on 2025-08-19T14:14:21.687Z>",
            "testStrategy": "Test caching of existing jsonb geometry data. Verify cache invalidation works with polygon data updates across complete boundary dataset."
          },
          {
            "id": 5,
            "title": "Implement spatial operations with JavaScript for jsonb polygon data",
            "description": "Implement geographic operations using JavaScript algorithms for spatial queries and boundary calculations on existing jsonb polygon data",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Implement JavaScript-based spatial operations for existing jsonb polygon data. Create geographic query functions using coordinate calculations: point-in-polygon, distance calculations, boundary intersections. Add geographic coordinate transformations using standard projection formulas. Create optimized functions for jsonb polygon operations: pointInPolygon, calculateDistance, findIntersections. Use efficient algorithms for coordinate-based spatial queries without PostGIS dependencies on complete existing boundary dataset.",
            "testStrategy": "Test point-in-polygon algorithms with existing jsonb coordinate data. Verify distance calculations accuracy with real boundary coordinate pairs."
          },
          {
            "id": 6,
            "title": "Update database queries to use correct schema field names",
            "description": "Ensure all queries and data models use the correct production database schema field names identified in analysis",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Update all Supabase queries and TypeScript interfaces to use correct field names: `name_id` instead of `region_id` in annual_region_aggregates table queries, `additional_area_cleaned_m` instead of `additional_areas_cleaned_m` in area calculations, and `parent_id` instead of `parent_region_id` in regions table hierarchy queries. Verify all database interactions use production schema naming conventions. Update any existing type definitions and API response interfaces to match actual database structure including jsonb geometry field handling for existing boundary data.",
            "testStrategy": "Test all queries against production database to ensure field names match. Verify TypeScript compilation with updated interfaces. Test data retrieval and aggregation functions with correct field references using existing complete boundary data."
          },
          {
            "id": 7,
            "title": "Create TypeScript interfaces for jsonb geometry handling",
            "description": "Define comprehensive TypeScript interfaces and types for working with existing jsonb polygon geometry data throughout the application",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Create TypeScript interfaces for existing jsonb geometry structure: RegionGeometry, PolygonCoordinates, BoundaryData. Define types for coordinate pairs [longitude, latitude] and coordinate arrays. Add validation functions with proper type guards for jsonb polygon data. Create utility types for map rendering components that consume jsonb geometry. Implement type-safe functions for coordinate extraction and transformation. Ensure type compatibility across API routes, React components, and map libraries for all 226 existing regions with complete boundary coverage.",
            "testStrategy": "Test TypeScript compilation with jsonb geometry interfaces using existing boundary data. Verify type safety in coordinate processing functions. Test map component integration with typed existing jsonb data."
          }
        ]
      },
      {
        "id": 5,
        "title": "Build Interactive UK Map Component",
        "description": "Develop the core interactive map component using Leaflet with region selection, hover effects, tooltips, and responsive design",
        "status": "done",
        "dependencies": [
          3,
          4
        ],
        "priority": "high",
        "details": "Use Leaflet (open source, no API key required) with react-leaflet for the mapping implementation. Create MapComponent with TypeScript interfaces for region data. Implement region boundary rendering with GeoJSON. Add hover highlighting with CSS transitions. Create tooltip component showing region name and 2-3 key metrics on hover. Implement click handlers for region selection. Add zoom and pan controls with bounds limiting to UK. Optimize rendering performance for large boundary datasets using layer clustering or simplification. Handle touch interactions for mobile devices.",
        "testStrategy": "Test map rendering performance with full UK boundary data. Verify hover and click interactions across different regions. Test mobile touch responsiveness and zoom controls. Validate tooltip positioning and content accuracy.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure Leaflet with React-Leaflet",
            "description": "Install Leaflet and react-leaflet packages, then set up basic map configuration with TypeScript support",
            "status": "done",
            "dependencies": [],
            "details": "Install leaflet and react-leaflet packages with TypeScript definitions (@types/leaflet). Configure basic map container and initialization code using react-leaflet components. Set up CSS imports for Leaflet styles. Create initial MapComponent with proper TypeScript typing.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Define TypeScript Interfaces for Region Data",
            "description": "Create comprehensive TypeScript interfaces and types for region data, map properties, and component props",
            "status": "done",
            "dependencies": [],
            "details": "Define interfaces for RegionData, MapBounds, RegionProperties, TooltipData, and MapComponentProps. Include geometry types for GeoJSON features. Add type definitions for map events, hover states, and selection states. Ensure compatibility with Leaflet and react-leaflet types.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement GeoJSON Boundary Rendering",
            "description": "Set up region boundary rendering using GeoJSON data with proper styling and layer management using Leaflet's GeoJSON layer",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "Load UK region boundary GeoJSON data from ONS Geoportal API. Create GeoJSON layers using react-leaflet's GeoJSON component for different administrative levels. Implement region styling with appropriate colors and borders. Set up layer switching for different geographic levels (countries, counties, unitary authorities).",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Interactive Features - Hover and Click Handlers",
            "description": "Implement hover highlighting, click selection, and interactive map controls with proper event handling using Leaflet event system",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Add mouseover/mouseout event handlers for region highlighting using Leaflet's event system. Implement click handlers for region selection with visual feedback. Add CSS transitions for smooth hover effects. Create zoom and pan controls with UK bounds limiting using Leaflet's fitBounds. Handle keyboard navigation for accessibility.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create Tooltip Component with Dynamic Content",
            "description": "Build responsive tooltip component that displays region information and key metrics on hover using Leaflet's tooltip functionality",
            "status": "done",
            "dependencies": [
              2,
              4
            ],
            "details": "Create reusable Tooltip component using Leaflet's native tooltip system. Display region name and 2-3 key litter metrics. Implement smart positioning to avoid screen edges. Add loading states for async metric data. Style with consistent design system and proper contrast ratios using custom CSS classes.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Optimize Performance for Large Boundary Datasets",
            "description": "Implement performance optimizations including coordinate simplification and efficient rendering using Leaflet's performance features",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Implement coordinate simplification for detailed boundary data using Leaflet's simplification options. Use Leaflet's canvas renderer for better performance with many regions. Implement viewport-based rendering to load only visible regions. Add debouncing for hover events. Utilize Leaflet's built-in tile caching strategies.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Handle Mobile Touch Interactions and Responsive Design",
            "description": "Implement touch-optimized interactions and ensure responsive map behavior across all device sizes using Leaflet's mobile support",
            "status": "done",
            "dependencies": [
              4,
              5
            ],
            "details": "Configure Leaflet's built-in touch event handlers for mobile devices. Implement pinch-to-zoom and touch-pan gestures using Leaflet's touch interaction options. Adjust tooltip behavior for touch interactions (tap to show/hide). Ensure map controls are touch-friendly with appropriate sizing using Leaflet's mobile-optimized controls. Test responsive behavior on various screen sizes.\n<info added on 2025-08-19T15:10:01.820Z>\nImplementation completed successfully and integrated into main application. Resolved SSR issues with Next.js dynamic imports, added loading states and error handling, and integrated React Query for data fetching. Database connection validated with 226 regions containing JSONB MultiPolygon geometries, RLS configured for public read access. Confirmed smooth rendering performance with complex geometry data from /api/regions endpoint. Touch interactions, mobile responsiveness, and region selection state management fully implemented and tested across desktop (1200x800) and mobile (375x667) viewports. Map controls and zoom functionality working correctly on all devices. Interactive UK map now operational with real database data, ready for next development phase.\n</info added on 2025-08-19T15:10:01.820Z>",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Create Data Visualization Components Library",
        "description": "Build reusable chart components for displaying litter data using shadcn/ui charts, including bar charts, pie charts, and line charts",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "details": "Create chart component library using shadcn/ui charts: HorizontalBarChart for top 5 litter items, PieChart for material/source breakdowns, LineChart for historical trends. Implement responsive chart sizing with aspect ratios using ChartContainer. Add colorblind-safe palettes with patterns/textures using chart theming. Create chart tooltip components with custom formatting using ChartTooltip and ChartTooltipContent. Add percentage and count display options. Implement year-over-year percentage change indicators with color coding (green for decrease, red for increase). Support data loading states and empty state handling. Add chart accessibility with ARIA labels and keyboard navigation using built-in accessibility features.",
        "testStrategy": "Test chart rendering with various data sizes and edge cases. Verify responsive behavior across screen sizes. Test accessibility features with screen readers. Validate color contrast ratios and colorblind accessibility.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install shadcn/ui Charts and Design Component Architecture",
            "description": "Install shadcn/ui chart components and create the foundational architecture for the chart component library including TypeScript interfaces",
            "status": "pending",
            "dependencies": [],
            "details": "Install shadcn/ui chart components (npx shadcn@latest add chart). Define TypeScript interfaces for chart data, props, and configuration options. Create base chart wrapper component using ChartContainer for responsive sizing and common functionality. Set up component directory structure in components/charts/. Define chart theme interface and color palette structure compatible with shadcn/ui theming. Create utility functions for data transformation and formatting.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement HorizontalBarChart Component with shadcn/ui",
            "description": "Build the horizontal bar chart component using shadcn/ui chart primitives for displaying top 5 litter items",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Create HorizontalBarChart component using shadcn/ui Bar chart components and ChartContainer. Implement custom tooltips with ChartTooltip and ChartTooltipContent for litter item names, counts, and percentages. Add responsive sizing with ChartContainer's built-in aspect ratio handling. Support both count and percentage display modes. Implement data sorting for top N items display. Add proper accessibility labels using shadcn/ui's built-in accessibility features.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement PieChart and LineChart Components with shadcn/ui",
            "description": "Build pie chart and line chart components using shadcn/ui chart primitives for material/source breakdowns and historical trends",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Create PieChart component using shadcn/ui Pie chart with ChartContainer for material and source distribution. Implement LineChart component using shadcn/ui Line chart for historical trends with multiple data series support. Use ChartTooltip and ChartTooltipContent for interactive tooltips. Support year-over-year percentage change indicators with color coding using shadcn/ui theming. Implement responsive sizing with ChartContainer and mobile-optimized interactions.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Colorblind-Safe Theming and Accessibility with shadcn/ui",
            "description": "Create colorblind-accessible color palettes and implement comprehensive accessibility using shadcn/ui's theming system",
            "status": "pending",
            "dependencies": [
              2,
              3
            ],
            "details": "Design and implement colorblind-safe color palettes using shadcn/ui chart theming with distinct patterns and textures. Configure chart color variables in CSS custom properties. Leverage shadcn/ui's built-in accessibility features including ARIA labels, keyboard navigation, and screen reader support. Ensure WCAG-compliant color contrast ratios using shadcn/ui's color system. Add pattern fills as fallback for color differentiation in chart components.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement State Management and Component Documentation",
            "description": "Add loading states, error handling, and comprehensive documentation for all shadcn/ui chart components",
            "status": "pending",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement loading skeleton components compatible with ChartContainer for data fetching states. Add error boundary and error state handling with user-friendly messages. Create comprehensive component documentation and Storybook stories. Add chart export functionality leveraging shadcn/ui chart's native capabilities. Implement debounced resize handling using ChartContainer's responsive features. Add comprehensive unit and integration tests for all chart components.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Filter System and State Management",
        "description": "Build comprehensive filtering system with region selector, time period controls, and litter category filters using React Query",
        "details": "Create filter context using React Context API for UI state. Implement region selector with search functionality using shadcn/ui Select and Command components. Build time period selector supporting single year and year ranges with slider component. Create category checkboxes for litter type/source filtering. Add filter reset functionality. Implement URL search params synchronization for shareable links. Use React Query for server state management with proper cache invalidation. Add debounced filter updates to prevent excessive API calls. Store filter state in localStorage for session persistence.",
        "testStrategy": "Test filter combinations and state synchronization. Verify URL sharing functionality works correctly. Test filter persistence across browser sessions. Validate performance with rapid filter changes.",
        "priority": "high",
        "dependencies": [
          3,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Filter Context and State Management Setup",
            "description": "Set up React Context API for filter state management with TypeScript interfaces",
            "dependencies": [],
            "details": "Create FilterContext with React.createContext and FilterProvider component. Define TypeScript interfaces for filter state including region, time period, and category selections. Implement useFilters custom hook for context consumption. Set up initial filter state structure with proper typing. Create filter reducer for complex state updates.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Region Selector with Search Functionality",
            "description": "Build region selector component with search capabilities using shadcn/ui components",
            "dependencies": [
              "7.1"
            ],
            "details": "Create RegionSelector component using shadcn/ui Select and Command components. Implement search functionality with fuzzy matching for region names. Add hierarchical display showing country > county > unitary authority. Include clear selection option and multiple selection support. Add loading states for region data fetching.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build Time Period Controls and Date Range Selector",
            "description": "Create time period selector supporting single year and year ranges with slider component",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement TimePeriodSelector using shadcn/ui Slider for year range selection. Support both single year and year range modes with toggle. Add preset buttons for common periods (Last Year, Last 5 Years, All Time). Display selected period clearly with formatted date strings. Include validation for logical date ranges.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Category Filtering with Litter Type Checkboxes",
            "description": "Build category checkbox system for litter type and source filtering",
            "dependencies": [
              "7.1"
            ],
            "details": "Create CategoryFilter component with grouped checkboxes for litter types and sources. Implement select all/none functionality for each group. Add search/filter capability within categories. Include visual indicators for active filters. Support nested category hierarchies with parent/child relationships.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement URL Search Params Synchronization",
            "description": "Add URL synchronization for shareable filter states and browser navigation",
            "dependencies": [
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "Implement useSearchParams hook for URL state synchronization. Create URL serialization/deserialization for filter state. Support browser back/forward navigation with filter states. Generate shareable URLs with encoded filter parameters. Add URL validation and fallback for invalid parameters.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add Filter Persistence and Performance Optimization",
            "description": "Implement localStorage persistence and debounced updates with React Query integration",
            "dependencies": [
              "7.5"
            ],
            "details": "Add localStorage persistence for filter state across sessions. Implement debounced filter updates to prevent excessive API calls. Integrate with React Query for server state management and cache invalidation. Add filter reset functionality clearing all selections. Implement performance optimizations for rapid filter changes with useMemo and useCallback.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Create API Routes for Litter Data Analytics",
        "description": "Build Next.js API routes for fetching aggregated litter data with proper filtering, caching, and error handling using Supabase JavaScript client with correct field names and relationships",
        "status": "pending",
        "dependencies": [
          1,
          7
        ],
        "priority": "high",
        "details": "Create API routes in app/api/: /analytics/region/{id} for region-specific data, /analytics/trends for historical data, /analytics/materials and /analytics/sources for breakdowns. Implement direct Supabase client queries for pre-aggregated data from annual_*_aggregates tables using correct field names: `name_id` for region relationships, `additional_area_cleaned_m` for area calculations, and `aggregate_id` for linking to central fact table. Target production database with 2,288 annual_region_aggregates rows. Leverage Supabase's built-in REST API performance optimizations and automatic query optimization. Implement request validation using Zod schemas with Supabase's type safety. Add response caching with Next.js revalidation and Supabase's native caching. Handle edge cases like no data available for regions. Support batch queries for multiple regions. Add rate limiting for API protection. Implement proper error handling and logging using Supabase's connection pooling and automatic connection management.",
        "testStrategy": "Test API routes with various filter combinations using Supabase client and correct field names. Verify response times meet performance requirements (<200ms) with Supabase's optimizations. Test error handling for invalid requests and database failures. Validate data accuracy against Supabase queries using production schema with 2,288 aggregate rows.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design API Route Structure and Endpoints",
            "description": "Create the foundational API route structure with proper Next.js App Router organization and endpoint definitions using correct database field names",
            "status": "pending",
            "dependencies": [],
            "details": "Create API route files in app/api/analytics/: region/[id]/route.ts for region-specific data, trends/route.ts for historical trends, materials/route.ts for material breakdown, and sources/route.ts for source breakdown. Define TypeScript interfaces for request parameters and response schemas using correct field names: `name_id` for region relationships, `additional_area_cleaned_m` for area calculations, and `aggregate_id` for central fact table linking. Implement route handlers with proper HTTP method support (GET). Set up proper Next.js dynamic route configuration for region ID parameter. Create base response formatting utilities that account for production database structure with 2,288 annual_region_aggregates rows.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Supabase Client Queries for Aggregated Data",
            "description": "Build optimized Supabase client queries to fetch data from pre-aggregated tables using correct field names and established relationships",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Create Supabase client query functions for annual_*_aggregates tables using correct field names: `name_id` for region joins, `additional_area_cleaned_m` for area-based calculations, and `aggregate_id` for linking to central fact table. Implement region-specific queries with geographic filtering leveraging established relationships in production database with 2,288 aggregate rows. Build trend analysis queries for historical data comparison using Supabase's automatic query optimization. Create material and source breakdown queries with proper aggregation using Supabase's built-in aggregation functions. Leverage Supabase's native connection pooling and automatic query optimization. Implement batch query support for multiple regions using Supabase's bulk operations. Take advantage of Supabase's automatic caching strategies for analytics workloads.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Request Validation with Zod Schemas and Supabase Type Safety",
            "description": "Create comprehensive request validation using Zod schemas with correct field names and database relationships",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Define Zod schemas for each API endpoint's query parameters and request body using correct field names from production schema. Create validation schemas for region IDs (using `name_id` field), date ranges, filter parameters, and pagination options. Validate `additional_area_cleaned_m` calculations and `aggregate_id` references. Implement validation middleware for consistent error responses. Add input sanitization and type coercion. Create custom validation rules for geographic coordinates and date ranges. Implement schema composition for shared validation logic. Integrate with Supabase's TypeScript type generation for enhanced type safety with production database structure. Add validation error formatting for clear client feedback.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Set Up Response Caching with Next.js and Supabase Native Caching",
            "description": "Implement Next.js response caching combined with Supabase's built-in caching optimized for production database size",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Implement Next.js ISR (Incremental Static Regeneration) for cacheable responses optimized for 2,288 aggregate rows. Set up revalidation strategies with appropriate cache durations based on data update frequency and production database size. Add cache headers for browser and CDN optimization. Implement conditional requests with ETag support. Leverage Supabase's native caching strategies for database queries with aggregate tables. Take advantage of Supabase's automatic connection pooling for improved performance with established relationships. Create cache invalidation logic for data updates using `aggregate_id` tracking. Add response compression and pagination for large datasets. Implement rate limiting using Next.js middleware or external service integration.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create Error Handling and Logging System with Supabase Integration",
            "description": "Implement comprehensive error handling and logging for all API routes using correct field names and relationship validation",
            "status": "pending",
            "dependencies": [
              3,
              4
            ],
            "details": "Create centralized error handling middleware with proper HTTP status codes and field-specific error messages for `name_id`, `additional_area_cleaned_m`, and `aggregate_id` validation failures. Implement structured logging for API requests, errors, and performance metrics with production database context. Add error categorization (validation, database, system errors) including relationship constraint violations. Create custom error classes for different failure scenarios including Supabase-specific errors and missing aggregate relationships. Implement request/response logging with sanitization for sensitive data. Add monitoring hooks for error tracking and performance metrics with production database scale considerations. Handle edge cases like empty datasets, invalid regions using `name_id` lookups, and database connectivity issues using Supabase's automatic connection management. Create user-friendly error messages while logging detailed technical information about field validation failures. Leverage Supabase's built-in error handling and retry mechanisms for aggregate table queries.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Build Engagement Statistics Panel",
        "description": "Create the engagement statistics panel showing survey counts, volunteer numbers, and total beach length surveyed",
        "details": "Create EngagementStatsPanel component with responsive design. Display key metrics: number of surveys, volunteer count, total surveyed beach length. Implement real-time updates when filters change using React Query. Add metric comparison with previous period (year-over-year changes). Create loading skeletons for better UX. Add thousand/million number formatting (e.g., 1.2K, 1.5M). Use card-based layout with icons from Lucide React. Position fixed on right side (desktop) or below map (mobile). Include subtle animations for metric updates.",
        "testStrategy": "Test panel updates when filter changes occur. Verify responsive positioning across different screen sizes. Test metric calculation accuracy and formatting. Validate loading states and error handling.",
        "priority": "medium",
        "dependencies": [
          6,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Region Information Modal and Data Display",
        "description": "Create detailed region information modal with comprehensive litter data visualization and year-over-year comparisons",
        "details": "Create RegionInfoModal component using shadcn/ui Dialog. Display region name, geographic hierarchy, and data availability status. Show top 5 litter items with horizontal bar chart. Display material and source breakdown pie charts. Add average litter per 100m with trend indicators. Include historical trend line chart for selected time periods. Implement year-over-year percentage change displays with color coding. Handle regions with no data with clear messaging and alternative suggestions. Add modal close functionality and keyboard navigation. Implement modal state management with URL synchronization.",
        "testStrategy": "Test modal functionality across different regions and data states. Verify chart accuracy and responsive design within modal. Test keyboard navigation and accessibility features. Validate no-data state handling.",
        "priority": "high",
        "dependencies": [
          5,
          6,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up RegionInfoModal component with shadcn/ui Dialog",
            "description": "Create the base modal component structure using shadcn/ui Dialog with proper TypeScript interfaces and modal state management",
            "dependencies": [],
            "details": "Create RegionInfoModal component in components/ui/. Import and configure shadcn/ui Dialog, DialogContent, DialogHeader, DialogTitle, and DialogTrigger components. Define TypeScript interfaces for region data props. Implement basic modal open/close state management. Add modal overlay and proper z-index stacking. Set up responsive modal sizing for desktop and mobile. Include proper ARIA attributes for accessibility.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Design and implement modal layout with region information display",
            "description": "Create the comprehensive data display layout showing region hierarchy, geographic info, and data availability status",
            "dependencies": [
              "10.1"
            ],
            "details": "Design modal layout with header showing region name and close button. Create sections for geographic hierarchy (country > county > region). Add data availability indicators with status badges. Implement responsive grid layout for desktop and mobile. Add proper spacing and typography using Tailwind classes. Include loading states and skeleton components for async data. Handle long region names with text truncation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate charts and data visualizations within modal",
            "description": "Add horizontal bar chart for top 5 litter items, pie charts for material/source breakdown, and historical trend charts",
            "dependencies": [
              "10.2"
            ],
            "details": "Integrate existing chart components into modal layout. Create horizontal bar chart component for top 5 litter items with proper scaling. Add material breakdown pie chart with legend. Implement source breakdown pie chart with color coding. Create historical trend line chart with time period selector. Add year-over-year percentage change displays with color-coded indicators (green/red for increase/decrease). Ensure charts are responsive within modal constraints.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement no-data state handling and alternative suggestions",
            "description": "Handle regions with no data by displaying clear messaging and suggesting nearby regions with available data",
            "dependencies": [
              "10.2"
            ],
            "details": "Create EmptyState component for regions without litter data. Display clear messaging explaining data unavailability. Implement logic to suggest nearby regions with available data based on geographic proximity. Add buttons to navigate to suggested regions. Include data collection information and links to contribute data. Style empty state with appropriate icons and typography. Handle partial data scenarios where some metrics are available.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add keyboard navigation, accessibility features, and URL synchronization",
            "description": "Implement complete keyboard navigation, accessibility features, and URL state management for modal",
            "dependencies": [
              "10.1",
              "10.3"
            ],
            "details": "Add keyboard event handlers for Escape key to close modal, Tab navigation between interactive elements, and Enter/Space for selections. Implement focus management with focus trap within modal. Add ARIA labels and roles for screen reader support. Create URL synchronization to share modal state with query parameters. Implement browser back button handling to close modal. Add focus restoration when modal closes. Test with screen readers and keyboard-only navigation.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Add Accessibility Features and Mobile Optimization",
        "description": "Implement comprehensive accessibility features, mobile optimization, and performance enhancements for the application",
        "details": "Implement ARIA labels and roles for all interactive elements. Add keyboard navigation support for map, filters, and charts. Ensure color contrast ratios meet WCAG 2.1 AA standards. Add screen reader support with proper semantic HTML. Implement focus management and visual focus indicators. Optimize touch targets for mobile (minimum 44px). Add swipe gestures for mobile map navigation. Implement mobile-optimized layout with collapsible sections. Add loading indicators and skeleton screens. Optimize image loading with Next.js Image component. Implement service worker for offline capability (future enhancement).",
        "testStrategy": "Test with screen readers (NVDA, JAWS, VoiceOver). Verify keyboard-only navigation functionality. Test on various mobile devices and screen sizes. Validate color contrast with accessibility tools. Test touch interactions and gesture support.",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Performance Optimization and Production Deployment Setup",
        "description": "Implement production-ready optimizations, error handling, monitoring, and deployment configuration for Vercel and Supabase",
        "details": "Configure Next.js production optimizations: image optimization, bundle analysis, and code splitting. Implement proper error boundaries with user-friendly error pages. Add performance monitoring with Web Vitals tracking. Set up Sentry or similar for error tracking (optional). Configure Vercel deployment with proper environment variables. Set up Supabase production database with proper security rules. Add database connection pooling and query optimization. Implement proper CSP headers and security configurations. Add sitemap.xml and robots.txt. Configure analytics tracking (Google Analytics 4). Add proper TypeScript strict mode configurations.",
        "testStrategy": "Test production build performance with Lighthouse audits. Verify error handling in production environment. Test deployment process and rollback capabilities. Validate security headers and CSP configurations. Monitor Core Web Vitals metrics.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-15T10:33:31.832Z",
      "updated": "2025-08-19T14:34:12.077Z",
      "description": "Tasks for master context"
    }
  }
}