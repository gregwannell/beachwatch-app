{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Database Connection and Environment Configuration",
        "description": "Configure Supabase database connection using the JavaScript client and environment variables for the Beachwatch Data Explorer",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Install and configure Supabase JavaScript client for direct database access. Set up environment variables for database connection (SUPABASE_URL, SUPABASE_ANON_KEY). Create lib/supabase.ts for client configuration. Install dependency: @supabase/supabase-js. Optionally generate TypeScript types from database schema using Supabase CLI. This approach provides direct, type-safe database access perfect for read-heavy analytics use cases with built-in connection pooling and caching.",
        "testStrategy": "Verify database connection with a simple query test. Test Supabase client initialization and basic data fetching operations on regions table. Validate environment variables are properly loaded and client is configured correctly.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Supabase JavaScript client",
            "description": "Install @supabase/supabase-js dependency",
            "status": "done",
            "dependencies": [],
            "details": "Run npm install @supabase/supabase-js to add the Supabase client library",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure environment variables",
            "description": "Set up SUPABASE_URL and SUPABASE_ANON_KEY in environment configuration",
            "status": "done",
            "dependencies": [],
            "details": "Create or update .env.local with SUPABASE_URL and SUPABASE_ANON_KEY. Add these variables to .env.example for documentation. Ensure variables are properly typed in next.config.ts if needed",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Supabase client configuration",
            "description": "Create lib/supabase.ts with client setup",
            "status": "done",
            "dependencies": [],
            "details": "Create lib/supabase.ts file with createClient function from @supabase/supabase-js. Configure client with environment variables and appropriate options for Next.js Server Components",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Test database connection",
            "description": "Verify Supabase client can connect and query the database",
            "status": "done",
            "dependencies": [],
            "details": "Create a simple test to verify database connection by querying the regions table. Test both client-side and server-side usage patterns",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Generate TypeScript types (optional)",
            "description": "Generate TypeScript types from database schema",
            "status": "done",
            "dependencies": [],
            "details": "Use Supabase CLI to generate TypeScript types from the database schema for type-safe database operations. Configure type generation in package.json scripts",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Install and Configure Core Dependencies",
        "description": "Install required libraries for mapping, data visualization, state management, and UI components as specified in the PRD",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Install React Query (@tanstack/react-query) v5.x for server state management. Install shadcn/ui charts component using 'npx shadcn@latest add chart' for data visualization (this automatically includes recharts as a dependency). Install Leaflet with react-leaflet v4.x for mapping (open source alternative to Mapbox). Install Sonner v1.x for notifications. Add additional shadcn/ui components: Card, Button, Select, Checkbox, Slider, Tooltip, Dialog, Sidebar. Configure React Query with QueryClient and proper error boundaries.",
        "testStrategy": "Verify all dependencies are properly installed and importable. Test React Query client initialization. Validate shadcn/ui charts can render basic charts. Test Leaflet initialization with sample data.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Core Application Layout and Navigation Structure",
        "description": "Build the main application layout with responsive design, including map area, sidebar for filters, and engagement stats panel",
        "details": "Create responsive layout component with CSS Grid: map occupying ~70% width on desktop, full width on mobile. Implement collapsible left sidebar for filters using shadcn/ui Sidebar component. Create fixed engagement stats panel on right side (desktop) or below map (mobile). Add proper responsive breakpoints using Tailwind CSS. Implement header with application title and branding. Use Inter font from next/font/google for typography. Apply environmental color scheme (blues/greens) with CSS custom properties.",
        "testStrategy": "Test responsive behavior across desktop, tablet, and mobile viewports. Verify sidebar collapse/expand functionality. Test layout integrity with different content sizes.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement UK Geographic Regions Data Management",
        "description": "Create data models, API routes, and services for managing UK geographic regions with jsonb geometry data integration using Supabase JavaScript client",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Create API routes in app/api/regions/ for fetching region data using Supabase client. Implement direct Supabase queries for hierarchical region structure (country > county > unitary authority) leveraging built-in REST API. Create region service functions for data transformation handling existing jsonb geometry fields containing GeoJSON Polygon objects. Implement caching strategy with React Query and Supabase's built-in connection pooling. Add region boundary coordinate validation for jsonb polygon data. Handle geometry field structure: {\"type\": \"Polygon\", \"coordinates\": [[[lng, lat], [lng, lat], ...]]}. IMPORTANT: Use correct database schema field names - `name_id` in annual_region_aggregates table, `additional_area_cleaned_m` (not additional_areas_cleaned_m), and `parent_id` in regions table (not parent_region_id). Work with existing jsonb geometry field data for all 226 UK regions with complete boundary coverage across 4 hierarchy levels.",
        "testStrategy": "Test region data fetching with various geographic levels using Supabase client. Validate jsonb GeoJSON Polygon structure and coordinate integrity. Test region hierarchy queries for parent/child relationships using Supabase REST API. Verify API performance with large boundary datasets leveraging built-in connection pooling. Test queries against production schema using correct field names (name_id, additional_area_cleaned_m, parent_id). Test jsonb polygon coordinate processing for map rendering with existing complete boundary data.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create API routes for regions data with Supabase client",
            "description": "Implement Next.js API routes in app/api/regions/ using Supabase JavaScript client for fetching UK geographic regions data with jsonb geometry handling and proper error handling",
            "status": "done",
            "dependencies": [],
            "details": "Create API endpoints using Supabase client: GET /api/regions for all regions, GET /api/regions/[id] for specific region, GET /api/regions/hierarchy for parent-child relationships. Implement proper TypeScript interfaces for Supabase response objects including jsonb geometry field structure. Add input validation and error handling using Supabase error types. Configure rate limiting and CORS headers. Utilize Supabase's built-in connection pooling and automatic retries. Use correct schema field names: `parent_id` for region hierarchy queries. Handle jsonb geometry data extraction and parsing for API responses with existing boundary data.\n<info added on 2025-08-19T11:20:31.785Z>\nImplementation completed successfully. All three main API endpoints created with comprehensive query parameters and proper error handling. TypeScript interfaces integrated with Supabase client. Rate limiting, caching headers, and geometry validation implemented using existing utility functions. All schema field names correctly used including parent_id, name_id, and additional_area_cleaned_m for proper database integration.\n</info added on 2025-08-19T11:20:31.785Z>",
            "testStrategy": "Test API endpoints with jsonb geometry data extraction. Verify TypeScript interfaces handle jsonb polygon structure correctly."
          },
          {
            "id": 2,
            "title": "Implement Supabase queries for hierarchical region structure",
            "description": "Build database queries using Supabase JavaScript client to handle hierarchical UK region data structure with jsonb geometry data extraction from existing boundary data",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Create Supabase queries for nested region relationships using select with joins on `parent_id` field. Implement functions using supabase.from(): findRegionsByParent, getRegionHierarchy, searchRegionsByName. Include jsonb geometry field selection in queries for existing boundary data. Utilize Supabase's built-in filtering and ordering capabilities. Handle region type filtering (country, county, unitary authority) with Supabase query builders. Leverage automatic connection management and query optimization. Ensure queries use correct field name `parent_id` for hierarchy relationships and properly extract jsonb polygon data from the complete existing dataset.\n<info added on 2025-08-19T14:11:21.239Z>\n**Implementation Complete - Comprehensive Supabase Region Queries System**\n\nSuccessfully implemented full hierarchical region query system with RegionQueries class in region-queries.ts featuring findRegionsByParent, getRegionHierarchy, searchRegionsByName, getRegionPath, getRegionsByType, getRegionStatistics, and validateHierarchy functions. All queries properly use parent_id field and include efficient hierarchy building with Maps for O(1) lookups, descendant counting, and circular reference detection.\n\nCreated corresponding React Query hooks in use-region-queries.ts with complete cache management, query key factories, prefetch helpers, and mutation support. System includes comprehensive error handling, performance optimization, and flexible query options (includeGeometry, includeChildren, includeParent, includeAggregates, maxDepth, orderBy). Enhanced RegionWithRelations interface provides full type safety for hierarchical data structures.\n\nAll queries leverage Supabase's built-in REST API, connection pooling, and query builders for optimal performance with the existing UK regions dataset containing jsonb geometry fields.\n</info added on 2025-08-19T14:11:21.239Z>",
            "testStrategy": "Test queries return correct jsonb geometry structure alongside hierarchical data. Verify polygon coordinate extraction works correctly with existing boundary data."
          },
          {
            "id": 3,
            "title": "Implement jsonb GeoJSON processing for coordinate validation",
            "description": "Build GeoJSON processing pipeline for jsonb polygon data validation and coordinate processing without PostGIS geometry types using existing boundary data",
            "status": "done",
            "dependencies": [],
            "details": "Implement JavaScript-based coordinate validation for existing jsonb polygon data. Create functions to validate GeoJSON Polygon structure stored in jsonb fields. Add coordinate bounds checking using standard JavaScript geometry calculations. Implement polygon simplification algorithms for different zoom levels. Create functions: validateJsonbPolygon, simplifyPolygonCoordinates, calculatePolygonBounds, optimizeForZoom. Handle invalid geometries with JavaScript validation functions. Work directly with coordinate arrays from jsonb structure of existing complete boundary dataset.\n<info added on 2025-08-19T11:23:16.969Z>\nImplementation completed successfully with comprehensive geometry processing capabilities. Created three core modules: geometry-utils.ts with validation functions (validateJsonbPolygon/MultiPolygon, calculatePolygonBounds, simplifyPolygonCoordinates with Douglas-Peucker algorithm, optimizeForZoom, UK coordinate bounds checking), spatial-operations.ts with advanced algorithms (pointInPolygon using ray casting, calculateDistance with Haversine formula, calculatePolygonArea with Shoelace formula, findIntersections, createBuffer, executeSpatialQuery, CoordinateTransformations class), and region-geometry-service.ts as service layer (validateGeometry, processGeometry with metadata calculation, validateRegionFromDB, spatial query functions, batch processing). All functions implemented in pure JavaScript without PostGIS dependency, handle existing jsonb polygon structure correctly, include comprehensive error handling with coordinate bounds validation, ring closure checks, duplicate detection, and performance warnings for large geometries.\n</info added on 2025-08-19T11:23:16.969Z>",
            "testStrategy": "Test coordinate validation with existing jsonb polygon structures. Verify simplification maintains polygon integrity with real boundary data."
          },
          {
            "id": 4,
            "title": "Setup React Query caching with Supabase integration",
            "description": "Implement comprehensive caching strategy using React Query integrated with Supabase's built-in caching and real-time capabilities for jsonb geometry data",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Configure React Query client to work with Supabase client queries including jsonb geometry data from existing boundaries. Implement query keys structure for hierarchical caching with Supabase data. Add prefetching strategies using Supabase's connection pooling. Create cache invalidation rules integrated with Supabase real-time subscriptions. Set up background refetching leveraging Supabase's automatic retry mechanisms and built-in performance optimizations. Handle jsonb polygon data serialization in cache for all 226 regions.\n<info added on 2025-08-19T14:14:21.687Z>\nSuccessfully completed React Query caching implementation with comprehensive Supabase integration. Enhanced query-client.ts with Supabase-optimized configurations including custom retry logic for PGRST errors, exponential backoff with jitter, extended garbage collection for geometry data, and custom geometry serialization with validation. Implemented SupabaseQueryClient class with advanced caching methods including setGeometryCache with priority-based stale times, prefetchRegionHierarchy for progressive loading, invalidateRegionQueries with smart cascade invalidation, startBackgroundSync for automatic refreshing, optimizeMemoryUsage for large datasets, and getCacheStats for monitoring. Created supabase-query-provider.tsx with real-time subscriptions to regions and aggregates tables, automatic cache invalidation on database changes, background synchronization with configurable intervals, memory optimization with cleanup, connection status monitoring, and development debug component. Added cache-strategies.ts with production-ready CACHE_STRATEGIES for different data types, CachePreloadingStrategies for essential data and exploration workflows, CacheOptimizer with usage analysis and predictive prefetching, and CacheWarming for deployment optimization. The implementation properly handles jsonb polygon data serialization in cache, provides real-time cache invalidation synchronized with database changes, implements progressive loading for large boundary datasets, and efficiently manages all 226 UK regions with complete geometry coverage.\n</info added on 2025-08-19T14:14:21.687Z>",
            "testStrategy": "Test caching of existing jsonb geometry data. Verify cache invalidation works with polygon data updates across complete boundary dataset."
          },
          {
            "id": 5,
            "title": "Implement spatial operations with JavaScript for jsonb polygon data",
            "description": "Implement geographic operations using JavaScript algorithms for spatial queries and boundary calculations on existing jsonb polygon data",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Implement JavaScript-based spatial operations for existing jsonb polygon data. Create geographic query functions using coordinate calculations: point-in-polygon, distance calculations, boundary intersections. Add geographic coordinate transformations using standard projection formulas. Create optimized functions for jsonb polygon operations: pointInPolygon, calculateDistance, findIntersections. Use efficient algorithms for coordinate-based spatial queries without PostGIS dependencies on complete existing boundary dataset.",
            "testStrategy": "Test point-in-polygon algorithms with existing jsonb coordinate data. Verify distance calculations accuracy with real boundary coordinate pairs."
          },
          {
            "id": 6,
            "title": "Update database queries to use correct schema field names",
            "description": "Ensure all queries and data models use the correct production database schema field names identified in analysis",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Update all Supabase queries and TypeScript interfaces to use correct field names: `name_id` instead of `region_id` in annual_region_aggregates table queries, `additional_area_cleaned_m` instead of `additional_areas_cleaned_m` in area calculations, and `parent_id` instead of `parent_region_id` in regions table hierarchy queries. Verify all database interactions use production schema naming conventions. Update any existing type definitions and API response interfaces to match actual database structure including jsonb geometry field handling for existing boundary data.",
            "testStrategy": "Test all queries against production database to ensure field names match. Verify TypeScript compilation with updated interfaces. Test data retrieval and aggregation functions with correct field references using existing complete boundary data."
          },
          {
            "id": 7,
            "title": "Create TypeScript interfaces for jsonb geometry handling",
            "description": "Define comprehensive TypeScript interfaces and types for working with existing jsonb polygon geometry data throughout the application",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Create TypeScript interfaces for existing jsonb geometry structure: RegionGeometry, PolygonCoordinates, BoundaryData. Define types for coordinate pairs [longitude, latitude] and coordinate arrays. Add validation functions with proper type guards for jsonb polygon data. Create utility types for map rendering components that consume jsonb geometry. Implement type-safe functions for coordinate extraction and transformation. Ensure type compatibility across API routes, React components, and map libraries for all 226 existing regions with complete boundary coverage.",
            "testStrategy": "Test TypeScript compilation with jsonb geometry interfaces using existing boundary data. Verify type safety in coordinate processing functions. Test map component integration with typed existing jsonb data."
          }
        ]
      },
      {
        "id": 5,
        "title": "Build Interactive UK Map Component",
        "description": "Develop the core interactive map component using Leaflet with region selection, hover effects, tooltips, and responsive design",
        "status": "done",
        "dependencies": [
          3,
          4
        ],
        "priority": "high",
        "details": "Use Leaflet (open source, no API key required) with react-leaflet for the mapping implementation. Create MapComponent with TypeScript interfaces for region data. Implement region boundary rendering with GeoJSON. Add hover highlighting with CSS transitions. Create tooltip component showing region name and 2-3 key metrics on hover. Implement click handlers for region selection. Add zoom and pan controls with bounds limiting to UK. Optimize rendering performance for large boundary datasets using layer clustering or simplification. Handle touch interactions for mobile devices.",
        "testStrategy": "Test map rendering performance with full UK boundary data. Verify hover and click interactions across different regions. Test mobile touch responsiveness and zoom controls. Validate tooltip positioning and content accuracy.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure Leaflet with React-Leaflet",
            "description": "Install Leaflet and react-leaflet packages, then set up basic map configuration with TypeScript support",
            "status": "done",
            "dependencies": [],
            "details": "Install leaflet and react-leaflet packages with TypeScript definitions (@types/leaflet). Configure basic map container and initialization code using react-leaflet components. Set up CSS imports for Leaflet styles. Create initial MapComponent with proper TypeScript typing.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Define TypeScript Interfaces for Region Data",
            "description": "Create comprehensive TypeScript interfaces and types for region data, map properties, and component props",
            "status": "done",
            "dependencies": [],
            "details": "Define interfaces for RegionData, MapBounds, RegionProperties, TooltipData, and MapComponentProps. Include geometry types for GeoJSON features. Add type definitions for map events, hover states, and selection states. Ensure compatibility with Leaflet and react-leaflet types.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement GeoJSON Boundary Rendering",
            "description": "Set up region boundary rendering using GeoJSON data with proper styling and layer management using Leaflet's GeoJSON layer",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "Load UK region boundary GeoJSON data from ONS Geoportal API. Create GeoJSON layers using react-leaflet's GeoJSON component for different administrative levels. Implement region styling with appropriate colors and borders. Set up layer switching for different geographic levels (countries, counties, unitary authorities).",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Interactive Features - Hover and Click Handlers",
            "description": "Implement hover highlighting, click selection, and interactive map controls with proper event handling using Leaflet event system",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Add mouseover/mouseout event handlers for region highlighting using Leaflet's event system. Implement click handlers for region selection with visual feedback. Add CSS transitions for smooth hover effects. Create zoom and pan controls with UK bounds limiting using Leaflet's fitBounds. Handle keyboard navigation for accessibility.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create Tooltip Component with Dynamic Content",
            "description": "Build responsive tooltip component that displays region information and key metrics on hover using Leaflet's tooltip functionality",
            "status": "done",
            "dependencies": [
              2,
              4
            ],
            "details": "Create reusable Tooltip component using Leaflet's native tooltip system. Display region name and 2-3 key litter metrics. Implement smart positioning to avoid screen edges. Add loading states for async metric data. Style with consistent design system and proper contrast ratios using custom CSS classes.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Optimize Performance for Large Boundary Datasets",
            "description": "Implement performance optimizations including coordinate simplification and efficient rendering using Leaflet's performance features",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Implement coordinate simplification for detailed boundary data using Leaflet's simplification options. Use Leaflet's canvas renderer for better performance with many regions. Implement viewport-based rendering to load only visible regions. Add debouncing for hover events. Utilize Leaflet's built-in tile caching strategies.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Handle Mobile Touch Interactions and Responsive Design",
            "description": "Implement touch-optimized interactions and ensure responsive map behavior across all device sizes using Leaflet's mobile support",
            "status": "done",
            "dependencies": [
              4,
              5
            ],
            "details": "Configure Leaflet's built-in touch event handlers for mobile devices. Implement pinch-to-zoom and touch-pan gestures using Leaflet's touch interaction options. Adjust tooltip behavior for touch interactions (tap to show/hide). Ensure map controls are touch-friendly with appropriate sizing using Leaflet's mobile-optimized controls. Test responsive behavior on various screen sizes.\n<info added on 2025-08-19T15:10:01.820Z>\nImplementation completed successfully and integrated into main application. Resolved SSR issues with Next.js dynamic imports, added loading states and error handling, and integrated React Query for data fetching. Database connection validated with 226 regions containing JSONB MultiPolygon geometries, RLS configured for public read access. Confirmed smooth rendering performance with complex geometry data from /api/regions endpoint. Touch interactions, mobile responsiveness, and region selection state management fully implemented and tested across desktop (1200x800) and mobile (375x667) viewports. Map controls and zoom functionality working correctly on all devices. Interactive UK map now operational with real database data, ready for next development phase.\n</info added on 2025-08-19T15:10:01.820Z>",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Create Data Visualization Components Library",
        "description": "Build essential reusable chart components for displaying litter data using shadcn/ui charts, focusing on HorizontalBarChart for top 5 litter items and PieChart components for material and source breakdowns",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "details": "Create simplified chart component library using shadcn/ui charts: HorizontalBarChart for top 5 litter items and PieChart for material/source breakdowns. Implement responsive chart sizing with aspect ratios using ChartContainer. Add colorblind-safe palettes with patterns/textures using chart theming. Create chart tooltip components with custom formatting using ChartTooltip and ChartTooltipContent. Add percentage and count display options. Support data loading states and empty state handling. Add chart accessibility with ARIA labels and keyboard navigation using built-in accessibility features. LineChart and historical trends functionality will be implemented in a future iteration.",
        "testStrategy": "Test chart rendering with various data sizes and edge cases. Verify responsive behavior across screen sizes. Test accessibility features with screen readers. Validate color contrast ratios and colorblind accessibility.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install shadcn/ui Charts and Design Component Architecture",
            "description": "Install shadcn/ui chart components and create the foundational architecture for the chart component library including TypeScript interfaces",
            "status": "done",
            "dependencies": [],
            "details": "Install shadcn/ui chart components (npx shadcn@latest add chart). Define TypeScript interfaces for chart data, props, and configuration options. Create base chart wrapper component using ChartContainer for responsive sizing and common functionality. Set up component directory structure in components/charts/. Define chart theme interface and color palette structure compatible with shadcn/ui theming. Create utility functions for data transformation and formatting.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement HorizontalBarChart Component with shadcn/ui",
            "description": "Build the horizontal bar chart component using shadcn/ui chart primitives for displaying top 5 litter items",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Create HorizontalBarChart component using shadcn/ui Bar chart components and ChartContainer. Implement custom tooltips with ChartTooltip and ChartTooltipContent for litter item names, counts, and percentages. Add responsive sizing with ChartContainer's built-in aspect ratio handling. Support both count and percentage display modes. Implement data sorting for top N items display. Add proper accessibility labels using shadcn/ui's built-in accessibility features.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement PieChart Component with shadcn/ui",
            "description": "Build pie chart component using shadcn/ui chart primitives for material and source distribution breakdowns",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Create PieChart component using shadcn/ui Pie chart with ChartContainer for material and source distribution. Use ChartTooltip and ChartTooltipContent for interactive tooltips showing percentages and counts. Implement responsive sizing with ChartContainer and mobile-optimized interactions. Support switching between material type and source breakdowns using the same component. Add legend component with proper spacing and alignment using shadcn/ui styling.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Colorblind-Safe Theming and Accessibility with shadcn/ui",
            "description": "Create colorblind-accessible color palettes and implement comprehensive accessibility using shadcn/ui's theming system",
            "status": "done",
            "dependencies": [
              2,
              3
            ],
            "details": "Design and implement colorblind-safe color palettes using shadcn/ui chart theming with distinct patterns and textures. Configure chart color variables in CSS custom properties. Leverage shadcn/ui's built-in accessibility features including ARIA labels, keyboard navigation, and screen reader support. Ensure WCAG-compliant color contrast ratios using shadcn/ui's color system. Add pattern fills as fallback for color differentiation in chart components.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement State Management and Component Documentation",
            "description": "Add loading states, error handling, and basic documentation for the essential shadcn/ui chart components",
            "status": "done",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement loading skeleton components compatible with ChartContainer for data fetching states. Add error boundary and error state handling with user-friendly messages. Create basic component documentation with usage examples. Implement debounced resize handling using ChartContainer's responsive features. Add essential unit tests for both chart components focusing on rendering and basic interactions.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Filter System and State Management",
        "description": "Build simplified filtering system with region selector, time period controls, and litter category filters using local state management",
        "status": "done",
        "dependencies": [
          3,
          6
        ],
        "priority": "high",
        "details": "Create simple filter state using useState hooks for UI state management. Implement RegionSelect component with search functionality using shadcn/ui Select and Command components. Build YearRangePicker component supporting single year and year ranges using slider or input components. Create CategoryCheckboxes component for litter type and source filtering. Add simple reset functionality to clear all filters. Integrate with existing React Query hooks for data fetching without additional complexity. Focus on core functionality without URL synchronization, localStorage persistence, or advanced debouncing - leveraging React Query's built-in caching for performance.",
        "testStrategy": "Test filter combinations and proper state updates. Verify filter reset functionality works correctly. Test integration with React Query data fetching. Validate filter performance with React Query caching.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create RegionSelect Filter Component",
            "description": "Build region selector using shadcn/ui Select with basic search functionality",
            "details": "Create RegionSelect component using existing shadcn/ui Select and Command components. Add basic search filtering for region names. Display regions in hierarchical format (Country > County). Handle selection changes and pass to parent component via props. No complex state management - just controlled component pattern.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 2,
            "title": "Create YearRangePicker Component",
            "description": "Build simple year range selector using slider or input components",
            "details": "Create YearRangePicker component using shadcn/ui Slider or Input components. Support single year and year range selection. Add preset buttons for common periods (Last 5 Years, All Time). Handle min/max validation based on available data years. Use controlled component pattern with props for value changes.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 3,
            "title": "Create CategoryCheckboxes Component",
            "description": "Build litter category filtering with checkbox groups for types and sources",
            "details": "Create CategoryCheckboxes component using shadcn/ui Checkbox components. Organize categories into logical groups (material types, sources). Add select all/none functionality per group. Handle checkbox state changes and pass selected categories to parent via props. Keep it simple with controlled component pattern.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 4,
            "title": "Integrate Filter Components with React Query",
            "description": "Replace placeholder filters in page.tsx and connect to data fetching with reset functionality",
            "details": "Update the FilterSidebar in page.tsx to use the new filter components. Add useState hooks for filter state management. Connect filter changes to React Query hooks for data fetching. Implement simple reset functionality to clear all filters. Update map and charts to respond to filter state changes. Keep implementation simple with direct prop passing.",
            "status": "done",
            "dependencies": [
              1,
              2,
              3
            ],
            "parentTaskId": 7
          }
        ]
      },
      {
        "id": 8,
        "title": "Create API Routes for Litter Data Analytics",
        "description": "Build simple Next.js API routes for fetching aggregated litter data following existing app patterns, with basic error handling and caching using Supabase JavaScript client",
        "status": "done",
        "dependencies": [
          1,
          7
        ],
        "priority": "high",
        "details": "Create basic API routes in app/api/analytics/: /region/[id] for region-specific data, /trends for historical data, /materials and /sources for breakdowns. Follow existing patterns from materials/regions routes. Implement simple Supabase client queries for annual_*_aggregates tables using correct field names: `name_id` for region relationships, `additional_area_cleaned_m` for area calculations, and `aggregate_id` for linking. Use basic Next.js revalidate for caching. Add simple parameter validation and basic error handling. Keep it simple and functional for the 2,288 aggregate rows in the database.",
        "testStrategy": "Test API routes with basic filter combinations. Verify responses return correct data using Supabase client. Test simple error handling for invalid requests. Validate data accuracy against database queries.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic API Route Structure",
            "description": "Set up simple API route files following existing app patterns with basic Next.js App Router organization",
            "status": "done",
            "dependencies": [],
            "details": "Create API route files in app/api/analytics/: region/[id]/route.ts, trends/route.ts, materials/route.ts, and sources/route.ts. Follow existing patterns from materials and regions routes. Define basic TypeScript interfaces for responses using correct field names: `name_id`, `additional_area_cleaned_m`, and `aggregate_id`. Implement simple GET handlers with basic parameter extraction. Keep structure simple and consistent with existing codebase.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Basic Supabase Queries",
            "description": "Create simple Supabase client queries for fetching data from aggregated tables using correct field names",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Build straightforward Supabase queries for annual_*_aggregates tables using correct field names: `name_id` for region joins, `additional_area_cleaned_m` for area calculations, and `aggregate_id` for central table linking. Create simple select queries with basic filtering. Follow existing query patterns from the app. Handle region-specific data fetching and basic trend analysis. Keep queries simple and focused on essential functionality.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add Basic Parameter Validation and Error Handling",
            "description": "Implement simple parameter validation and basic error handling following existing app patterns",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Add basic parameter validation for region IDs, date ranges, and filter options. Use simple JavaScript validation rather than complex schema libraries. Implement basic error responses with appropriate HTTP status codes. Handle common cases like invalid region IDs and missing parameters. Follow existing error handling patterns from materials/regions routes. Keep validation simple and focused on preventing basic errors.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Simple Caching with Next.js Revalidate",
            "description": "Add basic response caching using Next.js revalidate following existing app caching patterns",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Implement basic caching using Next.js revalidate with appropriate time intervals for analytics data. Add simple cache headers for browser caching. Follow existing caching patterns from the app. Set reasonable revalidate times based on data update frequency. Keep caching strategy simple and effective for the app's scale with 2,288 aggregate rows.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Build Engagement Statistics Panel",
        "description": "Create the engagement statistics panel showing survey counts, volunteer numbers, and total beach length surveyed",
        "details": "Create EngagementStatsPanel component with responsive design. Display key metrics: number of surveys, volunteer count, total surveyed beach length. Implement real-time updates when filters change using React Query. Add metric comparison with previous period (year-over-year changes). Create loading skeletons for better UX. Add thousand/million number formatting (e.g., 1.2K, 1.5M). Use card-based layout with icons from Lucide React. Position fixed on right side (desktop) or below map (mobile). Include subtle animations for metric updates.",
        "testStrategy": "Test panel updates when filter changes occur. Verify responsive positioning across different screen sizes. Test metric calculation accuracy and formatting. Validate loading states and error handling.",
        "priority": "medium",
        "dependencies": [
          6,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Region Information Modal and Data Display",
        "description": "Create detailed region information side panel with comprehensive litter data visualization and year-over-year comparisons",
        "status": "pending",
        "dependencies": [
          5,
          6,
          8
        ],
        "priority": "high",
        "details": "Create RegionInfoPanel component using shadcn/ui Sheet for slide-in panel. Display region name, geographic hierarchy, and data availability status. Show top 5 litter items with horizontal bar chart. Display material and source breakdown pie charts. Add average litter per 100m with simple year-over-year percentage change badge in header (green for improvement/decrease, red for worsening/increase, gray for no change). Handle regions with no data with clear messaging and alternative suggestions. Add scrollable panel design that doesn't interrupt map interaction. Focus on clean, responsive layout optimized for side panel viewing.",
        "testStrategy": "Test panel functionality across different regions and data states. Verify chart accuracy and responsive design within panel constraints. Test scrolling behavior and panel state management. Validate no-data state handling and badge color coding accuracy.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up RegionInfoPanel component with shadcn/ui Sheet",
            "description": "Create the base side panel component structure using shadcn/ui Sheet with proper TypeScript interfaces and panel state management",
            "status": "done",
            "dependencies": [],
            "details": "Create RegionInfoPanel component in components/ui/. Import and configure shadcn/ui Sheet, SheetContent, SheetHeader, SheetTitle, and SheetTrigger components. Define TypeScript interfaces for region data props. Implement basic panel open/close state management. Configure panel to slide in from right side. Set up responsive panel sizing for desktop and mobile. Include proper ARIA attributes for accessibility. Ensure panel doesn't interfere with map interactions.\n<info added on 2025-08-20T10:35:04.495Z>\nComponent updated to use shadcn/ui Sheet implementation with right-side slide-in panel configured to avoid map interaction conflicts. Sheet configuration ensures proper z-index layering and responsive behavior across devices.\n</info added on 2025-08-20T10:35:04.495Z>\n<info added on 2025-08-20T10:38:15.010Z>\nComponent successfully implemented with complete TypeScript interface structure including RegionData with nested litterData properties for comprehensive data handling. File created at correct location (src/components/region-info-panel.tsx) with full Sheet component integration including SheetContent, SheetHeader, SheetTitle, and SheetTrigger. Panel configured with responsive sizing using Tailwind classes (w-full sm:max-w-md) and proper scrolling behavior with overflow-y-auto. State management implemented with isOpen/onClose props for external control. Accessibility enhanced with labelledby and describedby attributes for screen reader support.\n</info added on 2025-08-20T10:38:15.010Z>",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Design scrollable panel layout with region information display",
            "description": "Create the comprehensive scrollable data display layout showing region hierarchy, geographic info, data availability status, and header badge",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Design panel layout with header showing region name, year-over-year change badge, and close button. Implement year-over-year percentage change badge with color coding (green for improvement/decrease, red for worsening/increase, gray for no change). Create scrollable sections for geographic hierarchy (country > county > region). Add data availability indicators with status badges. Implement responsive layout optimized for side panel width. Add proper spacing and typography using Tailwind classes. Include loading states and skeleton components for async data. Handle long region names with text truncation.\n<info added on 2025-08-20T10:39:15.369Z>\nSuccessfully implemented comprehensive scrollable panel layout with all required components: YearOverYearBadge with color coding (green for improvement/decrease, red for worsening/increase, gray for neutral), GeographicHierarchy showing country > county > region breadcrumb, DataAvailabilityStatus with visual indicators and average litter display. Added LoadingSkeleton component for async data states. Implemented responsive layout with proper scrolling behavior using maxHeight calc and overflow-y-auto. Added text truncation for long region names and proper spacing with Tailwind classes. Task completed successfully and ready for integration with charts and data visualizations in subtask 10.3.\n</info added on 2025-08-20T10:39:15.369Z>",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate charts and data visualizations within scrollable panel",
            "description": "Add horizontal bar chart for top 5 litter items and pie charts for material/source breakdown optimized for panel width",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Integrate existing chart components into scrollable panel layout. Create horizontal bar chart component for top 5 litter items with proper scaling for panel width. Add material breakdown pie chart with legend optimized for side panel viewing. Implement source breakdown pie chart with color coding suitable for narrower layout. Ensure charts are responsive within panel width constraints. Add proper spacing between chart sections for optimal scrolling experience. Remove trend line charts and complex historical visualizations.\n<info added on 2025-08-20T10:35:23.718Z>\nConfirmed chart optimization strategy for panel layout. Implemented horizontal bar chart with responsive width scaling for top 5 litter items display. Added compact pie chart components for material and source breakdown with optimized legends for narrow panel viewing. Removed all trend line and complex historical visualization components to maintain panel performance. Charts now properly scale within panel width constraints with appropriate responsive breakpoints. Applied consistent spacing between chart sections to ensure smooth scrolling experience within the side panel layout.\n</info added on 2025-08-20T10:35:23.718Z>\n<info added on 2025-08-20T10:40:16.323Z>\nSuccessfully completed chart integration within scrollable panel layout. Implemented HorizontalBarChart component with specified configuration (height=200, maxItems=5, showCount=true) for top 5 litter items visualization. Added Material Breakdown and Source Breakdown pie charts using PieChart components with optimized settings (height=200, showLegend=true, showPercentage=true) for narrow panel display. Completed proper data mapping from RegionData interface to BarChartData and PieChartData interfaces ensuring type safety. Implemented conditional rendering logic for charts with appropriate spacing optimization for panel width constraints. Verified removal of all complex historical visualization components as specified in requirements.\n</info added on 2025-08-20T10:40:16.323Z>",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement no-data state handling and alternative suggestions",
            "description": "Handle regions with no data by displaying clear messaging and suggesting nearby regions with available data within the panel",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Create EmptyState component for regions without litter data optimized for panel layout. Display clear messaging explaining data unavailability. Implement logic to suggest nearby regions with available data based on geographic proximity. Add buttons to navigate to suggested regions within the panel interface. Include data collection information and links to contribute data. Style empty state with appropriate icons and typography suitable for side panel. Handle partial data scenarios where some metrics are available.\n<info added on 2025-08-20T10:42:38.218Z>\nImplementation completed successfully with comprehensive EmptyState component featuring database icon and clear no-data messaging. Added SuggestedRegion interface to type definitions and suggestedRegions array to RegionData structure. EmptyState displays 'Contribute Data' button linking to Marine Conservation Society website. Implemented nearby regions suggestions with data availability badges indicating full, partial, or limited data status. Added navigation functionality allowing users to select suggested regions directly from the panel. Created information section explaining data collection process and encouraging user contributions. Enhanced RegionInfoPanel with onRegionSelect callback prop to support region navigation from suggestions. Added comprehensive partial data scenario handling using Info notification component to alert users when some metrics are available but detailed breakdowns are missing.\n</info added on 2025-08-20T10:42:38.218Z>",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add keyboard navigation and accessibility features for panel",
            "description": "Implement keyboard navigation, accessibility features, and focus management for the side panel interface",
            "status": "done",
            "dependencies": [
              1,
              3
            ],
            "details": "Add keyboard event handlers for Escape key to close panel, Tab navigation between interactive elements within panel, and Enter/Space for selections. Implement focus management with focus trap within panel when open. Add ARIA labels and roles for screen reader support specific to panel interface. Implement focus restoration when panel closes. Ensure panel doesn't interfere with map keyboard navigation when closed. Test with screen readers and keyboard-only navigation. Remove URL synchronization functionality.\n<info added on 2025-08-20T10:35:40.051Z>\nUpdated keyboard navigation implementation to focus on core accessibility features without URL synchronization. Removed URL state management functionality. Simplified keyboard handlers to include Escape key for panel closing and Tab navigation within panel boundaries. Maintained focus trap implementation within open panel. Ensured proper focus restoration to triggering element when panel closes. Verified panel keyboard navigation remains isolated from map controls when panel is closed, preventing interference with map keyboard interactions.\n</info added on 2025-08-20T10:35:40.051Z>\n<info added on 2025-08-20T10:44:02.446Z>\nSuccessfully completed comprehensive keyboard navigation and accessibility implementation. Added proper Escape key handler with clean event listener management. Implemented full ARIA support including dialog role, modal true state, and proper labelledby/describedby relationships. Enhanced semantic HTML structure with sections, headings, and appropriate ARIA roles (region, list, listitem). Added descriptive aria-labels for all interactive buttons. Implemented screen reader support with sr-only text descriptions for chart data visualization. Successfully established focus management system that maintains isolation from map navigation controls. Completed accessibility testing with screen readers and verified full keyboard-only navigation functionality across all panel features.\n</info added on 2025-08-20T10:44:02.446Z>",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Add Accessibility Features and Mobile Optimization",
        "description": "Implement comprehensive accessibility features, mobile optimization, and performance enhancements for the application",
        "details": "Implement ARIA labels and roles for all interactive elements. Add keyboard navigation support for map, filters, and charts. Ensure color contrast ratios meet WCAG 2.1 AA standards. Add screen reader support with proper semantic HTML. Implement focus management and visual focus indicators. Optimize touch targets for mobile (minimum 44px). Add swipe gestures for mobile map navigation. Implement mobile-optimized layout with collapsible sections. Add loading indicators and skeleton screens. Optimize image loading with Next.js Image component. Implement service worker for offline capability (future enhancement).",
        "testStrategy": "Test with screen readers (NVDA, JAWS, VoiceOver). Verify keyboard-only navigation functionality. Test on various mobile devices and screen sizes. Validate color contrast with accessibility tools. Test touch interactions and gesture support.",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Performance Optimization and Production Deployment Setup",
        "description": "Implement production-ready optimizations, error handling, monitoring, and deployment configuration for Vercel and Supabase",
        "details": "Configure Next.js production optimizations: image optimization, bundle analysis, and code splitting. Implement proper error boundaries with user-friendly error pages. Add performance monitoring with Web Vitals tracking. Set up Sentry or similar for error tracking (optional). Configure Vercel deployment with proper environment variables. Set up Supabase production database with proper security rules. Add database connection pooling and query optimization. Implement proper CSP headers and security configurations. Add sitemap.xml and robots.txt. Configure analytics tracking (Google Analytics 4). Add proper TypeScript strict mode configurations.",
        "testStrategy": "Test production build performance with Lighthouse audits. Verify error handling in production environment. Test deployment process and rollback capabilities. Validate security headers and CSP configurations. Monitor Core Web Vitals metrics.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-15T10:33:31.832Z",
      "updated": "2025-08-20T10:44:06.229Z",
      "description": "Tasks for master context"
    }
  }
}